package projet_NF20;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;


public class Kruskal {
	
	private int sommet1; //sommet1
	private int sommetAdjacent; //sommet2
	private int tmpPoids; //poids de l'arête
	private int indexSommetAdjacent;
	
	private ArrayList<ArrayList<Integer>> temp; //ici stock temporairement juste les arêtes
	//private ArrayList<ArrayList<ArrayList<Integer>>> temp; //pour remplacer plus tars temp et temp1 en stockant les arêtes et le poids
	private ArrayList<Integer> sommetParcouru; //liste des sommets parcourus pour l'algorithme
	//à enlever si utilisation de ArrayList<ArrayList<ArrayList<Integer>>> temp
	private int[][] temp1; //matrice avec les poids
	
	private Graphe g; //graphe à étudier
	private ArrayList<ArrayList<ArrayList<Integer>>> gr; //liste où l'on va stocker la liste3d
	private ArrayList<Integer> test; //
	
	public Kruskal(Graphe g){
		sommet1 = 0;
		sommetAdjacent = 0;
		tmpPoids = -1;
		indexSommetAdjacent = -1;
		temp = new ArrayList<ArrayList<Integer>>();
		//temp = new ArrayList<ArrayList<ArrayList<Integer>>>();
		sommetParcouru = new ArrayList<Integer>();
		this.g = g;
		this.gr = g.getList3D();
		temp1 = new int[this.gr.size()][this.gr.size()];
		test = new ArrayList<Integer>();
	}
	
	public /*ArrayList<ArrayList<ArrayList<Integer>>>*/ int[][] kruskal(){
		triCroissant();
	//	affichageList3D();
		
		boolean b = true;
		
		for(int l = 0; l<this.gr.size()-1; l++){
			affichageList3D();
			//trouve la plus petite arête
			trouverPetiteArete();
			
			
			//test des sommets que retourne la méthode
			System.out.println("Sommet:" + sommet1+ " |  Sommet adjacent:" + sommetAdjacent+ " |  Poids:"+tmpPoids);
			
			//stock dans la matrice le poid
			temp1[sommet1][sommetAdjacent] = tmpPoids;
			//temp.get(sommet1).get(sommetAdjacent).set(1, tmpPoids);
			
			//enlève la plus petite arête trouvée pour ne pas la reprendre
			//gr.get(sommet1).get(indexSommetAdjacent).remove(1);
			supprimerSommet();
			/*gr.get(sommet1).get(indexSommetAdjacent).set(1,-1);*/
			
			//regarder si dans temp il y a un sommet qui est maintenant dans SommetParcouru
			//si oui, ajouter le sommet manquant
			regarderTemp(); 
			
			ajoutSommet(b);
			afficherListSommetsParcourus();
		}
		Set set = new HashSet() ;
        set.addAll(sommetParcouru) ;
        sommetParcouru.clear();
        sommetParcouru = new ArrayList(set) ;
        sommetParcouru.toString();
		return /*temp*/ temp1;
	}
	
	public void supprimerSommet(){
		this.gr.get(sommet1).remove(indexSommetAdjacent);
		for (int j = 0; j < this.gr.get(indexSommetAdjacent).size() ; j++) {
			if(this.gr.get(sommetAdjacent).get(j).get(0) == sommet1){
				this.gr.get(sommetAdjacent).remove(j);
			}
		}
	}
	
	public void triCroissant()
	{
		boolean trie;
	  
		long debut = System.currentTimeMillis();
		for (int i = 0; i < this.gr.size() ; i++) {
			int taille = this.gr.get(i).size();
			do
			{
				trie = false;
			    for(int j=0 ; j < taille-1 ; j++)
			    {
			        if(this.gr.get(i).get(j).get(1) > this.gr.get(i).get(j+1).get(1))
			        {
			          	int tempoSommet = this.gr.get(i).get(j).get(0).intValue();
			            int tempoPoids = this.gr.get(i).get(j).get(1).intValue();
			            this.gr.get(i).get(j).set(0, this.gr.get(i).get(j+1).get(0).intValue());
			            this.gr.get(i).get(j).set(1, this.gr.get(i).get(j+1).get(1).intValue());
			            this.gr.get(i).get(j+1).set(0, tempoSommet);
			            this.gr.get(i).get(j+1).set(1, tempoPoids);
			            trie = true;
			        }			       
			    }
			    taille--;
			}while(trie);
		}
		System.out.println("\n \n Temps d'éxécution tri Croissant: " + ((System.currentTimeMillis() - debut) / 1000) + "\n");
	}
	
	private void trouverPetiteArete(){
		this.tmpPoids=-1;
		this.sommet1=0;
		this.sommetAdjacent=0;
		this.indexSommetAdjacent=-1;
		
		for (int i = 0; i < gr.size();i++){
				if(tmpPoids==-1 || tmpPoids>gr.get(i).get(0).get(1)){
					//stock le poid
					tmpPoids = gr.get(i).get(0).get(1);
					//stock le sommet1
					sommet1 = i;
					//stock le sommet2 adjacent
					sommetAdjacent = gr.get(i).get(0).get(0);
					//Le sommet stocker
					indexSommetAdjacent = 0;
				}
			}
		}
	
	private void regarderTemp(){
		if(!temp.isEmpty()){
			for (int i = 0; i < temp.size(); i++){
				for (int j = 0; j < temp.get(i).size(); j++){
					for(int k = 0; k < sommetParcouru.size(); k++){
						//a changer si temp change
						if(temp.get(i).get(j)/*.get(O)*/==sommetParcouru.get(k)){
							sommetParcouru.addAll(temp.get(i));
							//à changer si temp change
							temp1[temp.get(i).get(0)][temp.get(i).get(1)] = gr.get(temp.get(i).get(0)).get(temp.get(i).get(1)).get(1);
							temp.get(i).clear();
						}
					}
				}
			}
		} 
	}
	
	private void testSommetParcouru(boolean b, ArrayList<Integer> test){
		//s'il n'y est pas
		if(!b){
			//parcour de la liste pour voir si sommetAdjacent y est
			for(int i = 0; i < sommetParcouru.size(); i++){
				//System.out.println("sommetAdjacent est il dans la liste ? "+sommetAdjacent);
				b = sommetAdjacent==sommetParcouru.get(i);
				//si il y est
				if(b){
					//j'ajoute sommet1 et je sors
					sommetParcouru.add(sommet1);
					break;
				}
			}
			//si aucun n'y est 
			if(!b){
				//les ajouter dans la liste temp
				System.out.println("temp : "+sommet1+" "+sommetAdjacent);
				if(temp.isEmpty()){
					test.add(sommet1);
					test.add(sommetAdjacent);
					temp.add(0,test);
				} else{
					test.add(sommet1);
					test.add(sommetAdjacent);
					temp.add(temp.size(),test);
				}
				test.clear();
			}
		}
	}
	
	private void ajoutSommet(boolean b){
		if (sommetParcouru.isEmpty()){
			sommetParcouru.add(sommet1);
			sommetParcouru.add(sommetAdjacent);
		}else{
			//parcour de la liste pour voir si sommet1 y est
			for(int i = 0; i < sommetParcouru.size(); i++){
				//System.out.println("sommet1 est il dans la liste ? "+sommet1);
				//si il y est
				if(sommet1==sommetParcouru.get(i)){
					//j'ajoute sommetAdjacent et je sors
					sommetParcouru.add(sommetAdjacent);
					break;
				}else if(sommetAdjacent==sommetParcouru.get(i)){
					sommetParcouru.add(sommetAdjacent);
				}
			}
			//testSommetParcouru(b, test);
		}
	}
	
	public void afficherListSommetsParcourus(){
		String res = "";
		for (int i = 0; i < this.sommetParcouru.size(); i++) {
			res+= sommetParcouru.get(i) + " ";
		}
		System.out.println("Liste des sommets parcourus: " + res);
	}
	
	public void affichageList3D() {
		long debut = System.currentTimeMillis();
		System.out.println("Affichage de l'ArrayList ");
		for (int i = 0; i < this.g.getList3D().size(); i++) {
			String affichage = "S " + i + " A : ";
			for (int j = 0; j < this.g.getList3D().get(i).size(); j++) {
				for (int j2 = 0; j2 < this.g.getList3D().get(i).get(j).size(); j2++) {
					affichage += this.g.getList3D().get(i).get(j).get(j2) + " ";
				}
			}
			System.out.println(affichage);
		}
		System.out.println("\n \n Temps d'éxécution affichage liste3D: " + ((System.currentTimeMillis() - debut) / 1000) + "\n");

	}
	
	public static void main(String[] args) {
		Graphe g = new Graphe("graphe_k5.dat");
		Kruskal k = new Kruskal(g);
		
		int[][] test = k.kruskal();
		
		  for(int i = 0 ; i < test.length; i++ ){
		   for(int j = 0; j< test.length; j++){
		    System.out.print(" "+test[i][j]);
		   }
		   System.out.print("\n");
		  }
	}
}

